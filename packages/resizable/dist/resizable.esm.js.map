{"version":3,"file":"resizable.esm.js","sources":["../../draggable/dist/draggable.esm.js","../lib/ResizeCore.tsx","../lib/Resizable.tsx"],"sourcesContent":["import React, { useRef, useCallback, useEffect, cloneElement, useState } from 'react';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar classnames = {exports: {}};\n\n/*!\n  Copyright (c) 2018 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n\n(function (module) {\n  /* global define */\n  (function () {\n\n    var hasOwn = {}.hasOwnProperty;\n\n    function classNames() {\n      var classes = [];\n\n      for (var i = 0; i < arguments.length; i++) {\n        var arg = arguments[i];\n        if (!arg) continue;\n        var argType = typeof arg;\n\n        if (argType === 'string' || argType === 'number') {\n          classes.push(arg);\n        } else if (Array.isArray(arg)) {\n          if (arg.length) {\n            var inner = classNames.apply(null, arg);\n\n            if (inner) {\n              classes.push(inner);\n            }\n          }\n        } else if (argType === 'object') {\n          if (arg.toString === Object.prototype.toString) {\n            for (var key in arg) {\n              if (hasOwn.call(arg, key) && arg[key]) {\n                classes.push(key);\n              }\n            }\n          } else {\n            classes.push(arg.toString());\n          }\n        }\n      }\n\n      return classes.join(' ');\n    }\n\n    if (module.exports) {\n      classNames.default = classNames;\n      module.exports = classNames;\n    } else {\n      window.classNames = classNames;\n    }\n  })();\n})(classnames);\n\nvar classNames = classnames.exports;\n\nfunction find(array, cb) {\n  if (!Array.isArray(array)) return undefined;\n\n  for (var i = 0, length = array.length; i < length; i += 1) {\n    if (cb.apply(cb, [array[i], i, array])) return array[i];\n  }\n\n  return undefined;\n}\nfunction isFunction(func) {\n  return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';\n}\nfunction isNum(number) {\n  return typeof number === 'number' && !Number.isNaN(number);\n}\n\nfunction _int(number) {\n  return parseInt(number, 10);\n}\nfunction snapToGrid(grid, pendingX, pendingY) {\n  var x = Math.round(pendingX / grid[0]) * grid[0];\n  var y = Math.round(pendingY / grid[1]) * grid[1];\n  return [x, y];\n}\nfunction canDragX(axis) {\n  return axis === 'both' || axis === 'x';\n}\nfunction canDragY(axis) {\n  return axis === 'both' || axis === 'y';\n}\n\nvar prefixes = ['Moz', 'Webkit', 'O', 'ms'];\n\nfunction kebabToTitleCase(str) {\n  var value = '';\n  var shouldCapitalize = true;\n\n  for (var i = 0; i <= str.length; i += 1) {\n    if (shouldCapitalize) {\n      value += value[i].toUpperCase();\n      shouldCapitalize = false;\n    } else if (str[i] === '-') {\n      shouldCapitalize = true;\n    } else {\n      value += str[i];\n    }\n  }\n\n  return value;\n}\n\nfunction browserPrefixToKey(prop, prefix) {\n  return prefix ? \"\".concat(prefix).concat(kebabToTitleCase(prop)) : prop;\n}\nfunction getPrefix() {\n  var prop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';\n  if (typeof window === 'undefined' || typeof window.document === 'undefined') return '';\n  var style = window.document.documentElement.style;\n  if (prop in style) return '';\n\n  for (var i = 0; i < prefixes.length; i += 1) {\n    if (browserPrefixToKey(prop, prefixes[i]) in style) {\n      return prefixes[i];\n    }\n  }\n\n  return '';\n}\nvar browserPrefix = getPrefix();\n\nfunction addClass(el, classname) {\n  if (el.classList) {\n    el.classList.add(classname);\n  } else if (!el.className.match(new RegExp(\"(?:^|\\\\s)\".concat(classname, \"(?!\\\\S)\")))) {\n    // eslint-disable-next-line no-param-reassign\n    el.className += \"\".concat(classname);\n  }\n}\nfunction removeClass(el, classname) {\n  if (el.classList) {\n    el.classList.remove(classname);\n  } else {\n    // eslint-disable-next-line no-param-reassign\n    el.className = el.className.replace(new RegExp(\"(?:^|\\\\s)\".concat(classname, \"(?!\\\\S)\"), 'g'), '');\n  }\n}\nfunction addEvent(el, event, handler, inputOptions) {\n  if (!el) return;\n\n  var options = _objectSpread2({\n    capture: true\n  }, inputOptions);\n\n  if (el.addEventListener) {\n    el.addEventListener(event, handler, options); // @ts-ignore\n  } else if (el.attachEvent) {\n    // @ts-ignore\n    el.attachEvent(\"on\".concat(event), handler);\n  } else {\n    // @ts-ignore\n    // eslint-disable-next-line no-param-reassign\n    el[\"on\".concat(event)] = handler;\n  }\n}\nfunction removeEvent(el, event, handler, inputOptions) {\n  if (!el) return;\n\n  var options = _objectSpread2({\n    capture: true\n  }, inputOptions);\n\n  if (el.removeEventListener) {\n    el.removeEventListener(event, handler, options); // @ts-ignore\n  } else if (el.detachEvent) {\n    // @ts-ignore\n    el.detachEvent(\"on\".concat(event), handler);\n  } else {\n    // @ts-ignore\n    // eslint-disable-next-line no-param-reassign\n    el[\"on\".concat(event)] = null;\n  }\n}\nvar matchsSelectorFunc = '';\nfunction matchSelector(el, selector) {\n  if (!matchsSelectorFunc) {\n    matchsSelectorFunc = find(['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'], function (method) {\n      return isFunction(el[method]);\n    });\n  }\n\n  if (!isFunction(el[matchsSelectorFunc])) return false;\n  return el[matchsSelectorFunc](selector);\n}\nfunction matchSelectorAndParent(el, selector, baseNode) {\n  var node = el;\n\n  do {\n    if (matchSelector(node, selector)) return true;\n    if (node === baseNode) return false;\n    node = node.parentNode;\n  } while (node);\n\n  return false;\n}\nfunction getTouch(e, indentifier) {\n  return e.targetTouches && find(e.targetTouches, function (t) {\n    return indentifier === t.indentifier;\n  }) || e.changedTouches && find(e.changedTouches, function (t) {\n    return indentifier === t.indentifier;\n  });\n}\nfunction getTouchIdentifier(e) {\n  if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;\n  if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;\n  return undefined;\n}\nfunction offsetFromParent(_ref, offsetParent, scale) {\n  var clientX = _ref.clientX,\n      clientY = _ref.clientY;\n  var isBody = offsetParent === offsetParent.ownerDocument.body;\n  var rect = isBody ? {\n    left: 0,\n    top: 0\n  } : offsetParent.getBoundingClientRect();\n  var x = (clientX + offsetParent.scrollLeft - rect.left) / scale;\n  var y = (clientY + offsetParent.scrollTop - rect.top) / scale;\n  return {\n    x: x,\n    y: y\n  };\n}\nfunction addUserSelectStyles(doc) {\n  if (!doc) return;\n  var styleEl = doc.getElementById('draggable-style-el');\n\n  if (!styleEl) {\n    styleEl = doc.createElement('style');\n    styleEl.setAttribute('type', 'text/css');\n    styleEl.id = 'draggable-style-el';\n    styleEl.innerHTML = '.draggable-transparent-selection *::-moz-selection { all: inherit; }\\n';\n    styleEl.innerHTML = '.draggable-transparent-selection *::selection { all: inherit; }\\n';\n    doc.getElementsByTagName('head')[0].appendChild(styleEl);\n  }\n\n  if (doc.body) addClass(doc.body, 'draggable-transparent-selection');\n}\nfunction removeUserSelectStyle(doc) {\n  if (!doc) return;\n\n  try {\n    if (doc.body) removeClass(doc.body, 'draggable-transparent-selection'); // @ts-ignore\n\n    if (doc.selection) {\n      // @ts-ignore\n      doc.getSelection.empty();\n    } else {\n      var selection = (doc.defaultView || window).getSelection();\n\n      if (selection && selection.type !== 'Caret') {\n        selection.removeAllRanges();\n      }\n    } // eslint-disable-next-line no-empty\n\n  } catch (e) {}\n}\nfunction outerWidth(node) {\n  var _node$ownerDocument, _node$ownerDocument$d;\n\n  var width = node.clientWidth;\n  var computedStyle = (_node$ownerDocument = node.ownerDocument) === null || _node$ownerDocument === void 0 ? void 0 : (_node$ownerDocument$d = _node$ownerDocument.defaultView) === null || _node$ownerDocument$d === void 0 ? void 0 : _node$ownerDocument$d.getComputedStyle(node);\n\n  if (computedStyle) {\n    width += _int(computedStyle.borderLeftWidth);\n    width += _int(computedStyle.borderRightWidth);\n  }\n\n  return width;\n}\nfunction outerHeight(node) {\n  var _node$ownerDocument2, _node$ownerDocument2$;\n\n  var height = node.clientHeight;\n  var computedStyle = (_node$ownerDocument2 = node.ownerDocument) === null || _node$ownerDocument2 === void 0 ? void 0 : (_node$ownerDocument2$ = _node$ownerDocument2.defaultView) === null || _node$ownerDocument2$ === void 0 ? void 0 : _node$ownerDocument2$.getComputedStyle(node);\n\n  if (computedStyle) {\n    height += _int(computedStyle.borderTopWidth) + _int(computedStyle.borderBottomWidth);\n    height += _int(computedStyle.borderBottomWidth);\n  }\n\n  return height;\n}\nfunction innerWidth(node) {\n  var _node$ownerDocument3, _node$ownerDocument3$;\n\n  var width = node.clientWidth;\n  var computedStyle = (_node$ownerDocument3 = node.ownerDocument) === null || _node$ownerDocument3 === void 0 ? void 0 : (_node$ownerDocument3$ = _node$ownerDocument3.defaultView) === null || _node$ownerDocument3$ === void 0 ? void 0 : _node$ownerDocument3$.getComputedStyle(node);\n\n  if (computedStyle) {\n    width -= _int(computedStyle.paddingLeft);\n    width -= _int(computedStyle.paddingRight);\n  }\n\n  return width;\n}\nfunction innerHeight(node) {\n  var _node$ownerDocument4, _node$ownerDocument4$;\n\n  var height = node.clientHeight;\n  var computedStyle = (_node$ownerDocument4 = node.ownerDocument) === null || _node$ownerDocument4 === void 0 ? void 0 : (_node$ownerDocument4$ = _node$ownerDocument4.defaultView) === null || _node$ownerDocument4$ === void 0 ? void 0 : _node$ownerDocument4$.getComputedStyle(node);\n\n  if (computedStyle) {\n    height -= _int(computedStyle.paddingTop);\n    height -= _int(computedStyle.paddingBottom);\n  }\n\n  return height;\n}\nfunction getTranslation(_ref2, positionOffset) {\n  var x = _ref2.x,\n      y = _ref2.y;\n  var unit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'px';\n  var translation = \"translate(\".concat(x).concat(unit, \", \").concat(y).concat(unit, \")\");\n\n  if (positionOffset) {\n    var defaultX = \"\".concat(typeof positionOffset.x === 'string' ? positionOffset.x : \"\".concat(positionOffset.x).concat(unit));\n    var defaultY = \"\".concat(typeof positionOffset.y === 'string' ? positionOffset.y : \"\".concat(positionOffset.y).concat(unit));\n    translation = \"translate(\".concat(defaultX, \", \").concat(defaultY, \")\").concat(translation);\n  }\n\n  return translation;\n}\nfunction createCSSTransform(controlPos, positionOffset) {\n  var translation = getTranslation(controlPos, positionOffset, 'px');\n  return _defineProperty({}, browserPrefixToKey('transform', browserPrefix), translation);\n}\nfunction createSVGTransform(controlPos, positionOffset) {\n  var translation = getTranslation(controlPos, positionOffset, '');\n  return translation;\n}\n\nfunction cloneBounds(bounds) {\n  return {\n    left: bounds.left,\n    right: bounds.right,\n    top: bounds.top,\n    bottom: bounds.bottom\n  };\n}\n\nfunction getBoundPosition(node, bounds, x, y) {\n  if (!bounds) return [x, y];\n  var newX = x;\n  var newY = y;\n  var newBounds = typeof bounds === 'string' ? {} : cloneBounds(bounds);\n  var ownerDocument = node.ownerDocument;\n  var ownerWindow = ownerDocument.defaultView;\n\n  if (typeof bounds === 'string' && ownerWindow) {\n    var boundNode;\n\n    if (bounds === 'parent') {\n      boundNode = node.parentNode;\n    } else {\n      boundNode = ownerDocument.querySelector(bounds);\n    }\n\n    if (!(boundNode instanceof ownerWindow.HTMLElement)) {\n      throw new Error(\"Bounds selector \\\"\".concat(bounds, \"\\\" not exist.\"));\n    }\n\n    var nodeStyle = ownerWindow.getComputedStyle(node);\n    var boundNodeStyle = ownerWindow.getComputedStyle(boundNode);\n    newBounds = {\n      left: -node.offsetLeft + _int(boundNodeStyle.paddingLeft) + _int(nodeStyle.marginLeft),\n      top: -node.offsetTop + _int(boundNodeStyle.paddingTop) + _int(nodeStyle.marginTop),\n      right: innerWidth(boundNode) - outerWidth(node) - node.offsetLeft + _int(boundNodeStyle.paddingRight) - _int(nodeStyle.marginRight),\n      bottom: innerHeight(boundNode) - outerHeight(node) - node.offsetTop + _int(boundNodeStyle.paddingBottom) - _int(nodeStyle.marginBottom)\n    };\n  }\n\n  if (typeof newBounds.right === 'number' && isNum(newBounds.right)) newX = Math.min(newX, newBounds.right);\n  if (typeof newBounds.bottom === 'number' && isNum(newBounds.bottom)) newY = Math.min(newY, newBounds.bottom);\n  if (typeof newBounds.left === 'number' && isNum(newBounds.left)) newX = Math.max(newX, newBounds.left);\n  if (typeof newBounds.top === 'number' && isNum(newBounds.top)) newY = Math.max(newY, newBounds.top);\n  return [newX, newY];\n}\nfunction getContnrolPosition(e, draggableRef, touchIndentifier, scale) {\n  var touchObj = typeof touchIndentifier === 'number' ? getTouch(e, touchIndentifier) : null;\n  if (!(draggableRef !== null && draggableRef !== void 0 && draggableRef.current) || typeof touchIndentifier === 'number' && !touchObj) return null;\n  var node = draggableRef.current;\n  var offsetParent = draggableRef.current.offsetParent || node.offsetParent || node.ownerDocument.body;\n  return offsetFromParent(touchObj || e, offsetParent, scale);\n}\nfunction createCoreData(ref, state, x, y) {\n  var isStart = !isNum(state.lastX);\n  var node = ref.current;\n\n  if (isStart) {\n    return {\n      node: node,\n      deltaX: 0,\n      deltaY: 0,\n      lastX: x,\n      lastY: y,\n      x: x,\n      y: y\n    };\n  }\n\n  return {\n    node: node,\n    deltaX: x - state.lastX,\n    deltaY: y - state.lastY,\n    lastX: state.lastX,\n    lastY: state.lastY,\n    x: x,\n    y: y\n  };\n}\nfunction createDraggableData(state) {\n  var coreData = state.coreData,\n      x = state.x,\n      y = state.y,\n      scale = state.scale;\n  return {\n    node: coreData.node,\n    x: x + coreData.deltaX / scale,\n    y: y + coreData.deltaY / scale,\n    deltaX: coreData.deltaX / scale,\n    deltaY: coreData.deltaY / scale,\n    lastX: x,\n    lastY: y\n  };\n}\n\nvar events = {\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    stop: 'mouseup'\n  },\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    stop: 'touchend'\n  }\n};\nvar dragEvent = events.mouse;\n\nvar DragCore = function DragCore(props) {\n  var children = props.children,\n      allowAnyClick = props.allowAnyClick,\n      disable = props.disable,\n      handle = props.handle,\n      cancel = props.cancel,\n      grid = props.grid,\n      domRef = props.domRef,\n      _props$scale = props.scale,\n      scale = _props$scale === void 0 ? 1 : _props$scale,\n      _props$enableUserSele = props.enableUserSelect,\n      enableUserSelect = _props$enableUserSele === void 0 ? true : _props$enableUserSele,\n      _props$onStart = props.onStart,\n      onStart = _props$onStart === void 0 ? function () {\n    return 0;\n  } : _props$onStart,\n      _props$onDrag = props.onDrag,\n      onDrag = _props$onDrag === void 0 ? function () {\n    return 0;\n  } : _props$onDrag,\n      _props$onStop = props.onStop,\n      onStop = _props$onStop === void 0 ? function () {\n    return 0;\n  } : _props$onStop,\n      _props$onMousedown = props.onMousedown,\n      onMousedown = _props$onMousedown === void 0 ? function () {\n    return 0;\n  } : _props$onMousedown;\n  var stateRef = useRef({\n    lastX: NaN,\n    lastY: NaN,\n    dragging: false,\n    touchIndentifier: undefined\n  }); // ref never use as function\n  // const domNode = ref as MutableRefObject<HTMLElement>\n\n  var domNode = useRef(null);\n  var handleDrag = useCallback(function (e) {\n    var state = stateRef.current;\n    var position = getContnrolPosition(e, domNode, state.touchIndentifier, scale);\n    if (position === null) return;\n    var x = position.x,\n        y = position.y;\n\n    if (Array.isArray(grid)) {\n      var _snapToGrid = snapToGrid(grid, x - state.lastX, y - state.lastY),\n          _snapToGrid2 = _slicedToArray(_snapToGrid, 2),\n          deltaX = _snapToGrid2[0],\n          deltaY = _snapToGrid2[1];\n\n      if (!deltaX && !deltaY) return;\n      x = state.lastX + deltaX;\n      y = state.lastY + deltaY;\n    }\n\n    var coreEvent = createCoreData(domNode, state, x, y);\n\n    var shouldUpdate = onDrag(e, coreEvent);\n\n    if (shouldUpdate === false) {\n      // TODO:\n      // Old browser support\n      try {\n        handleDragStop(new MouseEvent('mouseup'));\n      } catch (err) {\n        var event = document.createEvent('MouseEvent');\n        handleDragStop(event);\n      }\n\n      return;\n    }\n\n    stateRef.current = _objectSpread2(_objectSpread2({}, state), {}, {\n      lastX: x,\n      lastY: y\n    });\n  }, [domNode]);\n  var handleDragStop = useCallback(function (e) {\n    var state = stateRef.current;\n    if (!state.dragging) return;\n    var position = getContnrolPosition(e, domNode, state.touchIndentifier, scale);\n    if (position === null) return;\n    var x = position.x,\n        y = position.y;\n    var coreEvent = createCoreData(domNode, state, x, y);\n    var shouldContinune = onStop(e, coreEvent);\n    if (shouldContinune === false) return;\n\n    if (domNode.current && enableUserSelect) {\n      removeUserSelectStyle(domNode.current.ownerDocument);\n    }\n    stateRef.current = _objectSpread2(_objectSpread2({}, state), {}, {\n      dragging: false,\n      lastX: NaN,\n      lastY: NaN\n    });\n\n    if (domNode.current) {\n      // eslint-disable-next-line no-use-before-define\n      removeEvent(domNode.current.ownerDocument, dragEvent.move, handleDrag);\n      removeEvent(domNode.current.ownerDocument, dragEvent.stop, handleDragStop);\n    }\n  }, [domNode]);\n  /**\n   * Handle staring\n   * @param { MouseTouchEvent } e Event\n   */\n\n  var handleDragStart = useCallback(function (e) {\n    var state = stateRef.current;\n    if (onMousedown) onMousedown(e); // Only accept left click from mouse\n\n    if (!allowAnyClick && e.button !== 0) return;\n    var node = domNode.current;\n    var ownerDocument = node === null || node === void 0 ? void 0 : node.ownerDocument;\n\n    if (!node || !ownerDocument || !ownerDocument.body || !ownerDocument.defaultView) {\n      throw new Error('Draggable not mounted on DragStart');\n    } // Handle cancel \\ handle \\ disable prop.\n\n\n    if (disable || !(e.target instanceof ownerDocument.defaultView.Node) || handle && !matchSelectorAndParent(e.target, handle, node) || cancel && matchSelectorAndParent(e.target, cancel, node)) {\n      return;\n    } // Prevent scrolling on mobile device.\n\n\n    if (e.type === 'touchstart') e.preventDefault();\n    var touchIndentifier = getTouchIdentifier(e);\n    stateRef.current = _objectSpread2(_objectSpread2({}, state), {}, {\n      touchIndentifier: touchIndentifier\n    });\n    var position = getContnrolPosition(e, domNode, touchIndentifier, scale);\n    if (position === null) return;\n    var x = position.x,\n        y = position.y;\n    var coreEvent = createCoreData(domNode, state, x, y);\n    var shouldUpdate = onStart(e, coreEvent);\n    if (shouldUpdate === false) return;\n    if (enableUserSelect) addUserSelectStyles(ownerDocument);\n    stateRef.current = _objectSpread2(_objectSpread2({}, state), {}, {\n      dragging: true,\n      lastX: x,\n      lastY: y\n    });\n    addEvent(ownerDocument, dragEvent.move, handleDrag);\n    addEvent(ownerDocument, dragEvent.stop, handleDragStop);\n  }, [domNode]);\n  var onMouseDown = useCallback(function (e) {\n    dragEvent = events.mouse;\n    return handleDragStart(e);\n  }, []);\n  var onMouseUp = useCallback(function (e) {\n    dragEvent = events.mouse;\n    return handleDragStop(e);\n  }, []);\n  var onTouchStart = useCallback(function (e) {\n    dragEvent = events.touch;\n    return handleDragStart(e);\n  }, []);\n  var onTouchEnd = useCallback(function (e) {\n    dragEvent = events.touch;\n    return handleDragStop(e);\n  }, []);\n  useEffect(function () {\n    if (domNode.current) {\n      domRef === null || domRef === void 0 ? void 0 : domRef(domNode.current);\n      addEvent(domNode.current, events.touch.start, onTouchStart, {\n        passive: false\n      });\n    }\n\n    return function () {\n      if (domNode !== null && domNode !== void 0 && domNode.current) {\n        var ownerDocument = domNode.current.ownerDocument;\n        removeEvent(ownerDocument, events.mouse.move, handleDrag);\n        removeEvent(ownerDocument, events.touch.move, handleDrag);\n        removeEvent(ownerDocument, events.mouse.stop, handleDragStop);\n        removeEvent(ownerDocument, events.touch.stop, handleDragStop);\n        removeEvent(domNode.current, events.touch.start, onTouchStart, {\n          passive: false\n        });\n        if (enableUserSelect) removeUserSelectStyle(ownerDocument);\n      }\n    };\n  }, [domNode]);\n  return /*#__PURE__*/cloneElement(children, {\n    ref: domNode,\n    onMouseDown: onMouseDown,\n    onMouseUp: onMouseUp,\n    onTouchEnd: onTouchEnd\n  });\n};\n\nfunction useReferenceState(initialValue) {\n  var _useState = useState(initialValue),\n      _useState2 = _slicedToArray(_useState, 2),\n      state = _useState2[0],\n      setState = _useState2[1];\n\n  var reference = useRef(state);\n\n  var setRef = function setRef(value) {\n    reference.current = value;\n    setState(value);\n  };\n\n  return [reference, setRef, state];\n}\n\nvar Draggable = function Draggable(props) {\n  var _position$x, _position$y;\n\n  var children = props.children,\n      className = props.className,\n      _props$draggedClassNa = props.draggedClassName,\n      draggedClassName = _props$draggedClassNa === void 0 ? 'dragged' : _props$draggedClassNa,\n      _props$draggingClassN = props.draggingClassName,\n      draggingClassName = _props$draggingClassN === void 0 ? 'dragging' : _props$draggingClassN,\n      position = props.position,\n      bounds = props.bounds,\n      positionOffset = props.positionOffset,\n      _props$scale = props.scale,\n      scale = _props$scale === void 0 ? 1 : _props$scale,\n      _props$axis = props.axis,\n      axis = _props$axis === void 0 ? 'both' : _props$axis,\n      _props$startPosition = props.startPosition,\n      startPosition = _props$startPosition === void 0 ? {\n    x: 0,\n    y: 0\n  } : _props$startPosition,\n      onStop = props.onStop,\n      onStart = props.onStart,\n      onDrag = props.onDrag; // const domNode = useRef<HTMLElement>(null)\n  // const [domNode, setDomNode] = useState<HTMLElement | null>(null)\n\n  var _useReferenceState = useReferenceState({\n    dragging: false,\n    dragged: false,\n    x: (_position$x = position === null || position === void 0 ? void 0 : position.x) !== null && _position$x !== void 0 ? _position$x : startPosition.x,\n    y: (_position$y = position === null || position === void 0 ? void 0 : position.y) !== null && _position$y !== void 0 ? _position$y : startPosition.y,\n    prevPropsPos: _objectSpread2({}, position),\n    slackX: 0,\n    slackY: 0,\n    isElementSVG: false,\n    domNode: null\n  }),\n      _useReferenceState2 = _slicedToArray(_useReferenceState, 3),\n      stateRef = _useReferenceState2[0],\n      setState = _useReferenceState2[1],\n      refState = _useReferenceState2[2];\n\n  var _useState = useState({\n    style: _objectSpread2({}, children.props.style),\n    className: '',\n    transform: ''\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      childProps = _useState2[0],\n      setChildProps = _useState2[1]; // Effects\n\n\n  useEffect(function () {\n    if (typeof window.SVGAElement !== 'undefined' && stateRef.current.domNode instanceof window.SVGAElement) {\n      setState(_objectSpread2(_objectSpread2({}, stateRef.current), {}, {\n        isElementSVG: true\n      }));\n    }\n  }, [stateRef]);\n  useEffect(function () {\n    var _classNames;\n\n    var state = stateRef.current;\n    var controlled = Boolean(position);\n    var draggable = !controlled || state.dragging;\n    var validatePosition = position || startPosition;\n    var transformOpts = {\n      x: canDragX(axis) && draggable ? state.x : validatePosition.x,\n      y: canDragY(axis) && draggable ? state.y : validatePosition.y\n    };\n    var svgTransform = null;\n    var cssTransform = {};\n\n    if (state.isElementSVG) {\n      svgTransform = createSVGTransform(transformOpts, positionOffset);\n    } else {\n      cssTransform = createCSSTransform(transformOpts, positionOffset);\n    }\n\n    var classnames = classNames(className || '', children.props.className || '', (_classNames = {}, _defineProperty(_classNames, draggedClassName, state.dragged), _defineProperty(_classNames, draggingClassName, state.dragging), _classNames));\n    setChildProps({\n      style: _objectSpread2(_objectSpread2({}, childProps.style), cssTransform),\n      className: classnames,\n      transform: svgTransform || ''\n    });\n  }, [refState]);\n  useEffect(function () {\n    if (position && !stateRef.current.dragging) {\n      var x = position.x,\n          y = position.y;\n      setState(_objectSpread2(_objectSpread2({}, stateRef.current), {}, {\n        x: x,\n        y: y\n      }));\n    }\n  }, [position]); // Actions\n\n  var handleDragStart = useCallback(function (e, coreData) {\n    var state = stateRef.current;\n    var sholdStart = onStart && onStart(e, createDraggableData({\n      x: state.x,\n      y: state.y,\n      scale: scale,\n      coreData: coreData\n    }));\n    if (sholdStart === false) return false;\n    setState(_objectSpread2(_objectSpread2({}, state), {}, {\n      dragging: true,\n      dragged: true\n    }));\n    return undefined;\n  }, [stateRef]);\n  var handleDrag = useCallback(function (e, coreData) {\n    var state = stateRef.current;\n    if (!state.dragging) return undefined;\n    var uiData = createDraggableData({\n      x: state.x,\n      y: state.y,\n      scale: scale,\n      coreData: coreData\n    });\n    var newState = {\n      x: uiData.x,\n      y: uiData.y,\n      slackX: 0,\n      slackY: 0\n    }; // if (bounds) {\n\n    var x = newState.x,\n        y = newState.y;\n    newState.x += state.slackX;\n    newState.y += state.slackY;\n\n    if (state.domNode) {\n      var _getBoundPosition = getBoundPosition(state.domNode, bounds, newState.x, newState.y),\n          _getBoundPosition2 = _slicedToArray(_getBoundPosition, 2),\n          newStateX = _getBoundPosition2[0],\n          newStateY = _getBoundPosition2[1];\n\n      newState.x = newStateX;\n      newState.y = newStateY;\n      newState.slackX = state.slackX + (x - newState.x);\n      newState.slackY = state.slackY + (y - newState.y);\n    }\n\n    uiData.x = newState.x;\n    uiData.y = newState.y;\n    uiData.deltaX = newState.x - state.x;\n    uiData.deltaY = newState.y - state.y; // }\n\n    var shouldUpdate = onDrag && onDrag(e, uiData);\n    if (shouldUpdate === false) return false;\n    setState(_objectSpread2(_objectSpread2({}, state), newState));\n    return undefined;\n  }, [stateRef]);\n  var handleDragStop = useCallback(function (e, coreData) {\n    var state = stateRef.current;\n    if (!state.dragging) return undefined;\n    var shouldContinune = onStop && onStop(e, coreData);\n    if (shouldContinune === false) return false;\n    var newState = {\n      dragging: false,\n      slackX: 0,\n      slackY: 0\n    };\n    setState(_objectSpread2(_objectSpread2({}, state), newState));\n    return undefined;\n  }, [stateRef]);\n  return /*#__PURE__*/React.createElement(DragCore, _extends({}, _objectSpread2(_objectSpread2({}, props), {}, {\n    onStart: handleDragStart,\n    onDrag: handleDrag,\n    onStop: handleDragStop\n  }), {\n    domRef: function domRef(instace) {\n      setState(_objectSpread2(_objectSpread2({}, stateRef.current), {}, {\n        domNode: instace\n      }));\n    }\n  }), /*#__PURE__*/cloneElement(children, _objectSpread2({}, childProps)));\n};\n\nexport default Draggable;\nexport { DragCore };\n//# sourceMappingURL=draggable.esm.js.map\n","/* eslint-disable no-param-reassign */\n/* eslint-disable react/jsx-props-no-spreading */\nimport React, {\n  FC,\n  ReactElement,\n  cloneElement,\n  useCallback,\n  SyntheticEvent,\n  useRef,\n  CSSProperties,\n  useState\n} from 'react'\nimport { DragCore, Axis, DragCoreProps, DraggableData } from '@sliditor/draggable'\nimport { ResizeHandleAxis, ResizeEvent } from './types'\n\nexport type ResizeHandleFuction = (axis: ResizeHandleAxis) => ReactElement<any>\n\nexport interface ResizeProps {\n  axis?: Axis\n  style?: CSSProperties\n  height: number\n  width: number\n  draggableOpts?: DragCoreProps\n  lockAspectRatio?: boolean\n  handleSize?: [number, number]\n  maxConstraints?: [number, number]\n  minConstraints?: [number, number]\n  onResize?: ResizeEvent\n  onResizeStart?: ResizeEvent\n  onResizeStop?: ResizeEvent\n  handle?: ReactElement<any> | ResizeHandleFuction\n  resizeHandles?: ResizeHandleAxis[]\n  transformScale?: number\n  className?: string\n  children?: ReactElement\n}\n\nconst ResizeCore: FC<ResizeProps> = (props) => {\n  const {\n    className,\n    children,\n    handle,\n    draggableOpts,\n    lockAspectRatio,\n    axis = 'both',\n    resizeHandles = ['se'],\n    transformScale = 1,\n    minConstraints = [20, 20],\n    maxConstraints = [Infinity, Infinity]\n  } = props\n\n  // const [lastHandleRect, setLastHandle] = useState<DOMRect | null>(null)\n  const lastHandleRect = useRef<DOMRect | null>(null)\n  const slack = useRef<[number, number] | null>(null)\n  const state = useRef({\n    width: props.width,\n    height: props.height\n  })\n\n  const renderResizeHandle = useCallback(\n    (handleAxis: ResizeHandleAxis) => {\n      if (handle) {\n        if (typeof handle === 'function') {\n          return handle(handleAxis)\n        }\n        return handle\n      }\n\n      return <span className={`rc-resizable-handle is-${handleAxis}`} />\n    },\n    [handle]\n  )\n\n  const runConstraints = (w: number, h: number) => {\n    const [min, max] = [minConstraints, maxConstraints]\n    if (!min && !max) return [w, h]\n\n    // If constraining to min and max, we need to also fit width and height to aspect ratio.\n    if (lockAspectRatio) {\n      // const resizingHorizontally = h === props.height\n      const resizingHorizontally = h === state.current.height\n      if (resizingHorizontally) {\n        // const ratio = props.width / props.height\n        const ratio = state.current.width / state.current.height\n        h = w / ratio\n        w = h * ratio\n      } else {\n        // Take into account vertical resize with N/S handles on locked aspect\n        // ratio. Calculate the change height-first, instead of width-first\n        const ratio = state.current.height / state.current.width\n        w = h / ratio\n        h = w * ratio\n      }\n    }\n\n    const [oldW, oldH] = [w, h]\n\n    // Add slack to the values used to calculate bound position. This will ensure that if\n    // we start removing slack, the element won't react to it right away until it's been\n    // completely removed.\n    const [slackW, slackH] = slack.current || [0, 0]\n    w += slackW\n    h += slackH\n\n    if (min) {\n      w = Math.max(min[0], w)\n      h = Math.max(min[1], h)\n    }\n    if (max) {\n      w = Math.min(max[0], w)\n      h = Math.min(max[1], h)\n    }\n\n    // If the width or height changed, we must have introduced some slack. Record it for the next iteration.\n    slack.current = [slackW + (oldW - w), slackH + (oldH - h)]\n\n    return [w, h]\n  }\n\n  const resetData = () => {\n    lastHandleRect.current = null\n    slack.current = null\n  }\n\n  const resizeHandler =\n    (handleName: 'onResize' | 'onResizeStart' | 'onResizeStop', handleAxis: ResizeHandleAxis) =>\n    (e: SyntheticEvent, dragData: DraggableData) => {\n      let deltaX = dragData.deltaX / transformScale\n      let deltaY = dragData.deltaY / transformScale\n\n      if (handleName === 'onResizeStart') resetData()\n\n      const canDragX = (axis === 'both' || axis === 'x') && handleAxis !== 'n' && handleAxis !== 's'\n      const canDragY = (axis === 'both' || axis === 'y') && handleAxis !== 'e' && handleAxis !== 'w'\n\n      if (!canDragX && !canDragY) return\n\n      const axisVertical = handleAxis[0]\n      const axisHorizontal = handleAxis[handleAxis.length - 1]\n\n      const handleRect = dragData.node.getBoundingClientRect()\n      if (lastHandleRect.current !== null) {\n        if (axisHorizontal === 'w') {\n          const deltaLeftSinceLast = handleRect.left - lastHandleRect.current.left\n          deltaX += deltaLeftSinceLast\n        }\n        if (axisVertical === 'n') {\n          const deltaTopSinceLast = handleRect.top - lastHandleRect.current.top\n          deltaY += deltaTopSinceLast\n        }\n      }\n\n      lastHandleRect.current = handleRect\n\n      if (axisHorizontal === 'w') deltaX = -deltaX\n      if (axisHorizontal === 'n') deltaY = -deltaY\n\n      // let width = props.width + (canDragX ? deltaX / transformScale : 0)\n      // let height = props.height + (canDragY ? deltaY / transformScale : 0)\n      let width = state.current.width + (canDragX ? deltaX / transformScale : 0)\n      let height = state.current.height + (canDragY ? deltaY / transformScale : 0)\n      ;[width, height] = runConstraints(width, height)\n      const demensionsChanged = width !== state.current.width || height !== state.current.height\n\n      state.current = { width, height }\n      const cb = typeof props[handleName] === 'function' ? props[handleName] : null\n      const shouldSkipCb = handleName === 'onResize' && !demensionsChanged\n      if (cb && !shouldSkipCb) {\n        if (typeof e.persist === 'function') e.persist()\n        // cb(e, { node: dragData.node, size: { width, height }, handle: handleAxis })\n        cb(e, { node: dragData.node, size: state.current, handle: handleAxis })\n      }\n\n      if (handleName === 'onResizeStop') resetData()\n    }\n\n  if (!children) return null\n  return cloneElement(children, {\n    className: `${className || ''} rc-resizable`,\n    children: [\n      children?.props.children,\n      ...resizeHandles.map((pos) => (\n        <DragCore\n          {...draggableOpts}\n          key={`resiableHandle-${pos}`}\n          onStop={resizeHandler('onResizeStop', pos)}\n          onStart={resizeHandler('onResizeStart', pos)}\n          onDrag={resizeHandler('onResize', pos)}\n        >\n          {renderResizeHandle(pos)}\n        </DragCore>\n      ))\n    ]\n  })\n}\n\nexport default ResizeCore\n","/* eslint-disable react/jsx-props-no-spreading */\nimport React, { FC, useCallback, useRef, useState } from 'react'\nimport ResizeCore, { ResizeProps } from './ResizeCore'\nimport { ResizeEvent } from './types'\n\ninterface SizeState {\n  width: number\n  height: number\n  propsHeight?: number\n  propsWidth?: number\n}\n\nconst Resizable: FC<ResizeProps> = (props) => {\n  // const { width, height, style, onResize, children, ...resizeProps } = props\n  const {\n    handle,\n    handleSize,\n    onResize,\n    onResizeStart,\n    onResizeStop,\n    draggableOpts,\n    minConstraints,\n    maxConstraints,\n    lockAspectRatio,\n    axis,\n    width,\n    height,\n    resizeHandles,\n    style,\n    transformScale,\n    ...extraProps\n  } = props\n  const [state, setState] = useState<SizeState>({\n    width,\n    height,\n    propsWidth: width,\n    propsHeight: height\n  })\n  // const state = useRef({\n  //   width,\n  //   height,\n  //   propsWidth: width,\n  //   propsHeight: height\n  // })\n\n  const handleResize: ResizeEvent = useCallback((e, data) => {\n    const { size } = data\n\n    if (onResize) {\n      onResize(e, data)\n      e.persist?.()\n    }\n\n    setState(size)\n    // state.current = { ...state.current, ...size }\n  }, [])\n\n  return (\n    <ResizeCore\n      axis={axis}\n      draggableOpts={draggableOpts}\n      handle={handle}\n      handleSize={handleSize}\n      height={state.height}\n      lockAspectRatio={lockAspectRatio}\n      maxConstraints={maxConstraints}\n      minConstraints={minConstraints}\n      onResizeStart={onResizeStart}\n      onResize={handleResize}\n      onResizeStop={onResizeStop}\n      resizeHandles={resizeHandles}\n      transformScale={transformScale}\n      width={state.width}\n    >\n      <div\n        {...extraProps}\n        style={{ ...style, width: `${state.width}px`, height: `${state.height}px` }}\n      />\n    </ResizeCore>\n  )\n}\n\nexport default Resizable\n"],"names":["hasOwn","classes","i","arguments","arg","argType","Array","inner","classNames","Object","module","window","ResizeCore","props","className","children","handle","draggableOpts","lockAspectRatio","axis","resizeHandles","transformScale","minConstraints","maxConstraints","Infinity","lastHandleRect","useRef","slack","state","width","height","renderResizeHandle","useCallback","handleAxis","runConstraints","w","h","min","max","resizingHorizontally","current","ratio","oldW","oldH","slackW","slackH","Math","resetData","resizeHandler","handleName","e","dragData","deltaX","deltaY","canDragX","canDragY","axisVertical","axisHorizontal","length","handleRect","node","getBoundingClientRect","deltaLeftSinceLast","left","deltaTopSinceLast","top","demensionsChanged","cb","shouldSkipCb","persist","size","cloneElement","map","pos","Resizable","handleSize","onResize","onResizeStart","onResizeStop","style","extraProps","useState","propsWidth","propsHeight","setState","handleResize","data"],"mappings":"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"}